#region Using Declarations
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;

using PathwaysLib.SoapObjects;
using PathwaysLib.ServerObjects;
using PathwaysLib.Exceptions;
#endregion

namespace PathwaysLib.ServerObjects
{	

	#region Document Comments
	/// <sourcefile>
	///		<project>Pathways</project>
	///		<filepath>PathwaysLib/ServerObjects/ServerGene.cs</filepath>
	///		<creation>2005/06/23</creation>
	///		<author>
	///			<name>Brandon S. Evans</name>
	///			<initials>bse</initials>
	///			<email>brandon.evans@case.edu</email>
	///		</author>
	///		<contributors>
	///			<contributor>
	///				<name>Michael F. Starke</name>
	///				<initials>mfs</initials>
	///				<email>michael.starke@case.edu</email>
	///			</contributor>
	///			<contributor>
	///				<name>Brendan Elliott</name>
	///				<initials>BE</initials>
	///				<email>bxe7@cwru.edu</email>
	///			</contributor>
	///		</contributors>
	///		<cvs>
	///			<cvs_author>$Author: mustafa $</cvs_author>
	///			<cvs_date>$Date: 2008/05/16 21:15:53 $</cvs_date>
	///			<cvs_header>$Header: /var/lib/cvs/PathCase_SystemsBiology/PathwaysLib/ServerObjects/ServerGene.cs,v 1.1 2008/05/16 21:15:53 mustafa Exp $</cvs_header>
	///			<cvs_branch>$Name:  $</cvs_branch>
	///			<cvs_revision>$Revision: 1.1 $</cvs_revision>
	///		</cvs>
	///</sourcefile>
	/// <summary>
	/// Encapsulates database access related to biological Organisms.
	/// </summary>
	#endregion
	public class ServerGene : ServerMolecularEntity
	{

		#region Constructor, Destructor, ToString
		/// <summary>
		/// Default constructor
		/// </summary>
		protected ServerGene ( )
		{
		}

//        /// <summary>
//        /// Creates a new Gene.
//        /// 
//        /// The notes fields may be null.  
//        /// Specify ChromosomeID (gene is in a specific organism) or 
//        /// OrganismGroupID (gene is common to a group of organisms), but not both.
//        /// </summary>
//        /// <param name="name"></param>
//        /// <param name="rawAddress"></param>
//        /// <param name="molecular_entity_notes">May be null</param>
//        /// <param name="gene_group_id">If there is a homologous gene(s), use the GeneGroupId of that gene, otherwise leave this empty (Guid.Empty) to have a new gene group id be generated for this gene alone</param>
//        /// <param name="chromosome_id">Make this non-empty (not Guid.Empty) if this gene is present in a specific organism instead of in an Organism Group.  If this is entered, OrganismGroupId should be set to Guid.Empty!</param>
//        /// <param name="cytogenic_address"></param>
//        /// <param name="genetic_address"></param>
//        /// <param name="organism_group_id">Make this non-empty (not Guid.Empty) if this gene is present in a general organism group instead of in a specific organism.  If this is entered, ChromosomeId should be set to Guid.Empty!</param>
//        /// <param name="gene_notes">May be null</param>
//        /// <param name="relative_address"></param>
//(AC) This const. never worked
//        public ServerGene (string name, string molecular_entity_notes, Guid gene_group_id, Guid chromosome_id, string cytogenic_address, long genetic_address, Guid organism_group_id, string gene_notes, decimal relative_address, string rawAddress)
//            : base(name, "genes", molecular_entity_notes)
//        {
//            // not yet in DB, so create empty row
//            __GeneRow = new DBRow( __TableName );
//
//            this.ID = base.ID; // get ID generated by base class
//
//            if (gene_group_id != Guid.Empty)
//                this.GeneGroupID = gene_group_id;
//            else
//                this.GeneGroupID = DBWrapper.NewID();
//
//            this.ChromosomeID = chromosome_id;
//            this.CytogenicAddress = cytogenic_address;
//            this.GeneticAddress = genetic_address;
//            this.OrganismGroupID = organism_group_id;
//            this.GeneNotes = gene_notes;
//            this.RelativeAddress = relative_address;
//			this.RawAddress = rawAddress;
//
//        }

		/// <summary>
		/// Constructor for server gene wrapper.
		/// </summary>
		/// <remarks>
		/// This constructor creates a ServerGene object from a
		/// SoapGene object.  The base constructor must also be called here.
		/// </remarks>
		/// <param name="data">
		/// A SoapGene object from which to construct the
		/// ServerGene object.
		/// </param>
		public ServerGene ( SoapGene data ) 
			: base ( (SoapMolecularEntity)data, "genes")
		{
			// (BE) setup database row
			switch(data.Status)
			{
				case ObjectStatus.Insert:
					// not yet in DB, so create empty row
					__GeneRow = new DBRow( __TableName );
					break;
				case ObjectStatus.ReadOnly:
				case ObjectStatus.Update:
				case ObjectStatus.NoChanges:
					// need to load existing row first so update works properly
					__GeneRow = LoadRow(data.ID);
					break;
				default:
					throw new DataModelException("Cannot create ServerObject from invalid SoapObject.");
			}

			// (BE) get potential updates from Soap object, unless it's supposed to be read only
			if (data.Status != ObjectStatus.ReadOnly)
				UpdateFromSoap(data);
		}

		/// <summary>
		/// Constructor for server gene wrapper.
		/// </summary>
		/// <remarks>
		/// This constructor creates a ServerGene object from a
		/// DataSet.  The base constructor must also be called here.
		/// </remarks>
		/// <param name="geneRow">
		/// DataSet to load into the object.
		/// </param>
		public ServerGene ( DBRow geneRow ) 
            : base ( ServerMolecularEntity.LoadRow(geneRow.GetGuid("id") ) )
		{
			// (mfs)
			// setup object
			__GeneRow = geneRow;
		}

		/// <summary>
		/// Constructor given a base class row and the derived class row
		/// </summary>
		/// <param name="geneRow"></param>
		/// <param name="molecularEntityRow"></param>
		public ServerGene ( DBRow geneRow, DBRow molecularEntityRow ) 
            : base ( molecularEntityRow )
		{
			// (mfs)
			// setup object
			__GeneRow = geneRow;
		}

		/// <summary>
		/// Destructor for the ServerGene class.
		/// </summary>
		/// <remarks>
		/// Call base constructor to ensure proper updates.
		/// </remarks>
		~ServerGene()
		{
		}
		#endregion


		#region Member Variables
		private static readonly string __TableName = "genes";

		/// <summary>
		/// The contains the data for the derived class table.  Data from
		/// the base class table is maintained by the server base class.
		/// </summary>
		protected DBRow __GeneRow;
		#endregion


		#region Properties
		/// <summary>
		/// Get/set the gene ID.  
		/// This must be the same value as ServerMolecularEntity.ID,
		/// so we override it and set the base class value as well 
		/// in the setter.
		/// </summary>
		public override Guid ID
		{
			get
			{
				return __GeneRow.GetGuid("id");
			}
			set
			{
				base.ID = value; // (BE) update base class ID as well
				if (__GeneRow != null)
					__GeneRow.SetGuid("id", value); 
			}
		}

		/// <summary>
		/// Get/set the gene's group ID.  
		/// 
		/// A Gene group is used to identify homologous genes
		/// between different organisms.  This should be either
		/// set to the same value as another gene's GeneGroupId
		/// if they are homologous, or left empty and a new 
		/// GeneGroupId will be created at insertion.
		/// </summary>
		public Guid HomologueGroupID
		{
			get
			{
				return __GeneRow.GetGuid("homologue_group_id");
			}
			set
			{
				__GeneRow.SetGuid("homologue_group_id", value);
			}
		}

		/// <summary>
		/// Get/set the chromosomome ID.
		/// </summary>
		public Guid ChromosomeID
		{
			get
			{
				return __GeneRow.GetGuid("chromosome_id");
			}
			set
			{
				__GeneRow.SetGuid("chromosome_id", value);

                // can't have both organism group ID and chromosome ID! (see check constraint CK_genes)
                if (value != Guid.Empty)
                    __GeneRow.SetGuid("genetic_address", Guid.Empty);
            }
		}

		/// <summary>
		/// Get/set the cytogenic address.
		/// </summary>
		public string CytogenicAddress
		{
			get
			{
				return __GeneRow.GetString("cytogenic_address");
			}
			set
			{
				__GeneRow.SetString("cytogenic_address", value);
			}
		}
		
		/// <summary>
		/// Get/set the genetic address.
		/// </summary>
		public Long GeneticAddress
		{
			get
			{

				return __GeneRow.GetLong("genetic_address");
			}
			set
			{
				__GeneRow.SetLong("genetic_address", value);
			}
		}

		/// <summary>
		/// Get/set the organism group id.
		/// </summary>
		public Guid OrganismGroupID
		{
			get
			{
				return __GeneRow.GetGuid("organism_group_id");
			}
			set
			{
				__GeneRow.SetGuid("organism_group_id", value);

                // can't have both organism group ID and chromosome ID! (see check constraint CK_genes)
                if (value != Guid.Empty)
                    __GeneRow.SetGuid("chromosome_id", Guid.Empty);
            }
		}
		
		/// <summary>
		/// Get/set the notes.
		/// </summary>
		public string GeneNotes
		{
			get
			{
				return __GeneRow.GetString("notes");
			}
			set
			{
				__GeneRow.SetString("notes", value);
			}
		}

		/// <summary>
		/// Get/set the relative address.
		/// </summary>
		public long RelativeAddress
		{
			get
			{
				return __GeneRow.GetLong("relative_address");
			}
			set
			{
				__GeneRow.SetLong("relative_address", value);
			}
		}

		/// <summary>
		/// 
		/// </summary>
		public string RawAddress
		{
			get{return __GeneRow.GetString("raw_address");}
			set{ __GeneRow.SetString("raw_address", value);}
		}
		
		#endregion


		#region Methods
		/// <summary>
		/// Returns a representation of this object suitable for being
		/// sent to a client via SOAP.
		/// </summary>
		/// <returns>
		/// A SoapObject object capable of being passed via SOAP.
		/// </returns>
		public override SoapObject PrepareForSoap ( SoapObject derived )
		{
			SoapGene retval = (derived == null) ? 
				retval = new SoapGene() : retval = (SoapGene)derived;

			// (BE) fill base class properties
			base.PrepareForSoap(retval);
            
			retval.ID   = this.ID;
			retval.GeneGroupID = this.HomologueGroupID;
			retval.ChromosomeID = this.ChromosomeID;
			retval.CytogenicAddress   = this.CytogenicAddress;
			retval.GeneticAddress = this.GeneticAddress;
			retval.OrganismGroupID = this.OrganismGroupID;
			retval.GeneNotes = this.GeneNotes;
			retval.RelativeAddress = this.RelativeAddress;
			retval.RawAddress = this.RawAddress;

			retval.Status = ObjectStatus.NoChanges;

			return retval;
		}

		/// <summary>
		/// Consumes a SoapObject object and updates the object
		/// from it.
		/// </summary>
		/// <param name="o">
		/// The SoapObject object to update from, potentially containing
		/// changes to the object.
		/// </param>
		protected override void UpdateFromSoap ( SoapObject o )
		{
			// set base class properties
			base.UpdateFromSoap(o);

			SoapGene g = o as SoapGene;

			// (BE) use the ID set in the base class or the new ID generated by the base class
			this.ID = base.ID;

            if (g.GeneGroupID != Guid.Empty)
			    this.HomologueGroupID = g.GeneGroupID;
            else
                this.HomologueGroupID = DBWrapper.NewID(); // not homologous to a known gene, give it its own gene group id!

			
			this.CytogenicAddress = g.CytogenicAddress;
			this.GeneticAddress = g.GeneticAddress;
			this.OrganismGroupID = g.OrganismGroupID;
			this.GeneNotes = g.GeneNotes;
			this.RelativeAddress = g.RelativeAddress;
			this.RawAddress = g.RawAddress;
			this.ChromosomeID = g.ChromosomeID;

			//Guid ids = this.ChromosomeID;
		}

		/// <summary>
		/// Update the base class's data row, then the derived class's row
		/// </summary>
		public override void UpdateDatabase()
		{
			base.UpdateDatabase ();
			__GeneRow.UpdateDatabase();
		}

        /// <summary>
        /// Deletes the ServerGene from the database.
        /// </summary>
		public override void Delete()
		{
			// (sfa) Delete the genes tuples
			DBWrapper.Instance.ExecuteNonQuery("DELETE FROM genes WHERE id = @id"
				, "@id", SqlDbType.UniqueIdentifier, this.ID);

			// delete the gene from molecular_entities table and entity-name related tables
			base.Delete ();
		}

		/// <summary>
		/// Gives all the homologues of this gene (list does not include this gene)
		/// </summary>
		/// <returns>
		/// an array of gene homologues this gene
		/// </returns>
		public ServerGene[] GetHomologues( )
		{
			SqlCommand command = new SqlCommand(@"
				SELECT g.*
					FROM " + __TableName + @" g
					WHERE g.homologue_group_id = @homologue_group_id AND g.id <> @id;" );
			SqlParameter groupId = new SqlParameter( "@homologue_group_id", SqlDbType.UniqueIdentifier );
			groupId.SourceVersion = DataRowVersion.Original;
			groupId.Value = this.HomologueGroupID;
			command.Parameters.Add( groupId );
			SqlParameter ident = new SqlParameter( "@id", SqlDbType.UniqueIdentifier );
			ident.SourceVersion = DataRowVersion.Original;
			ident.Value = this.ID;
			command.Parameters.Add( ident );

			DataSet[] ds = new DataSet[0];
			DBWrapper.LoadMultiple( out ds, ref command );

			ArrayList results = new ArrayList();
			foreach ( DataSet d in ds )
			{
				results.Add( new ServerGene( new DBRow(d) ) );
			}

			return ( ServerGene[] ) results.ToArray( typeof( ServerGene ) );
		}


		#region Chromosome and Organism relations
		/// <summary>
		/// Loads the chromosome for this gene
		/// </summary>
		/// <returns></returns>
		public ServerChromosome GetChromosome ( )
		{
			if ( this.ChromosomeID != Guid.Empty )
				return ServerChromosome.Load( this.ChromosomeID );
			else return null;
		}

		/// <summary>
		/// Returns the organism that has this gene
		/// </summary>
		/// <returns></returns>
		public ServerOrganism GetOrganism( )
		{
			return ServerGene.GetOrganismForGene ( this.ID );
		}
		#endregion

		#region Encodes Relation
		/// <summary>
		/// Adds an entry in the gene_encodings table
		/// </summary>
		/// <param name="gene_product_id"></param>
		public void AddGeneProductEncoding( Guid gene_product_id )
		{
			ServerGene.AddGeneEncoding( this.ID, gene_product_id );
		}

		/// <summary>
		/// Removes an entry in the gene_encodings table
		/// </summary>
		/// <param name="gene_product_id"></param>
		public void RemoveGeneProductEncoding( Guid gene_product_id )
		{
			ServerGene.RemoveGeneEncoding( this.ID, gene_product_id );
		}

		/// <summary>
		/// Gives all of the GeneProducts associated with this gene
		/// </summary>
		/// <returns>
		/// an array of Gene Products encoded by this gene
		/// </returns>
		public ServerGeneProduct[] GetAllGeneProducts( )
		{
			SqlCommand command = new SqlCommand(@"
				SELECT gp.*
				FROM gene_products gp
				INNER JOIN gene_encodings ge ON gp.[id] = ge.gene_product_id
				WHERE ge.gene_id = @id;" );
			SqlParameter ident = new SqlParameter( "@id", SqlDbType.UniqueIdentifier );
			ident.SourceVersion = DataRowVersion.Original;
			ident.Value = this.ID;
			command.Parameters.Add( ident );

			DataSet[] ds = new DataSet[0];
			DBWrapper.LoadMultiple( out ds, ref command );

			ArrayList results = new ArrayList();
			foreach ( DataSet d in ds )
			{
				results.Add( ServerGeneProduct.LoadFromRow( new DBRow( d ) ) );
			}

			return ( ServerGeneProduct[] ) results.ToArray( typeof( ServerGeneProduct ) );
		}

		#endregion

		#region ADO.NET SqlCommands
		/// <summary>
		/// Required function for settign up the SqlCommands for ADO.NET.
		/// </summary>
		protected override void SetSqlCommandParameters ( )
		{
			// (BE) set commands for base class's DBRow
			base.SetSqlCommandParameters();

            // (BE) tried rewriting, but there's a typo somewhere or the precision needs to be specified, since it was throwing a 'doesn't implement IConvertable' exception...

//            __GeneRow.ADOCommands["insert"] = DBWrapper.BuildCommand(
//                "INSERT INTO " + __TableName + " (id, group_id, chromosome_id, cytogenic_address, genetic_address, organism_group_id, notes, relative_address) VALUES (@id, @group_id, @chromosome_id, @cytogenic_address, @genetic_address, @organism_group_id, @notes, @relative_address);",
//                "@id", SqlDbType.UniqueIdentifier, ID,
//                "@group_id", SqlDbType.UniqueIdentifier, GeneGroupID,
//                "@chromosome_id", SqlDbType.UniqueIdentifier, ChromosomeID,
//                "@cytogenic_address", SqlDbType.VarChar, CytogenicAddress,
//                "@genetic_address", SqlDbType.BigInt, GeneticAddress,
//                "@organism_group_id", SqlDbType.UniqueIdentifier, OrganismGroupID,
//                "@notes", SqlDbType.Text, GeneNotes,
//                "@relative_address", SqlDbType.Decimal, RelativeAddress);
//
//            __GeneRow.ADOCommands["select"] = DBWrapper.BuildCommand(
//                "SELECT * FROM " + __TableName + " WHERE id = @id;",
//                "@id", SqlDbType.UniqueIdentifier, ID);
//
//            __GeneRow.ADOCommands["update"] = DBWrapper.BuildCommand(
//                "UPDATE " + __TableName + " SET group_id = @group_id, chromosome_id = @chromosome_id, cytogenic_address = @cytogenic_address, genetic_address = @genetic_address, organism_group_id = @organism_group_id, notes = @notes, relative_address = @relative_address WHERE id = @id;",                
//                "@group_id", SqlDbType.UniqueIdentifier, GeneGroupID,
//                "@chromosome_id", SqlDbType.UniqueIdentifier, ChromosomeID,
//                "@cytogenic_address", SqlDbType.VarChar, CytogenicAddress,
//                "@genetic_address", SqlDbType.BigInt, GeneticAddress,
//                "@organism_group_id", SqlDbType.UniqueIdentifier, OrganismGroupID,
//                "@notes", SqlDbType.Text, GeneNotes,
//                "@relative_address", SqlDbType.Decimal, RelativeAddress,
//                "@id", SqlDbType.UniqueIdentifier, ID);
//
//            __GeneRow.ADOCommands["delete"] = DBWrapper.BuildCommand(
//                "DELETE FROM " + __TableName + " WHERE id = @id;",
//                "@id", SqlDbType.UniqueIdentifier, ID);

			// (mfs)
			// add the INSERT command
			SqlCommand Insert = new SqlCommand( "INSERT INTO " + __TableName + " (id, homologue_group_id, chromosome_id, cytogenic_address, genetic_address, organism_group_id, notes, relative_address, raw_address) VALUES (@i_id, @i_group_id, @i_chromosome_id, @i_cytogenic_address, @i_genetic_address, @i_organism_group_id, @i_notes, @i_relative_address, @i_raw_address);" );
			SqlParameter i_id = new SqlParameter( "@i_id", SqlDbType.UniqueIdentifier, 32, "id" );
			i_id.Value = ID;
			Insert.Parameters.Add( i_id );
			SqlParameter i_group_id = new SqlParameter( "@i_group_id", SqlDbType.UniqueIdentifier, 32, "homologue_group_id" );
			i_group_id.Value = HomologueGroupID;
			Insert.Parameters.Add( i_group_id );
			SqlParameter i_chromosome_id = new SqlParameter( "@i_chromosome_id", SqlDbType.UniqueIdentifier, 32, "chromosome_id" );
			i_chromosome_id.Value = ChromosomeID;
			Insert.Parameters.Add( i_chromosome_id );
			SqlParameter i_cytogenic_address = new SqlParameter( "@i_cytogenic_address", SqlDbType.VarChar, 255, "cytogenic_address" );
			i_cytogenic_address.Value = CytogenicAddress;
			Insert.Parameters.Add( i_cytogenic_address );
			SqlParameter i_genetic_address = new SqlParameter( "@i_genetic_address", SqlDbType.BigInt, 100, "genetic_address" );
			i_genetic_address.Value = GeneticAddress;
			Insert.Parameters.Add( i_genetic_address );
			SqlParameter i_organism_group_id = new SqlParameter( "@i_organism_group_id", SqlDbType.UniqueIdentifier, 32, "organism_group_id" );
			i_organism_group_id.Value = OrganismGroupID;
			Insert.Parameters.Add( i_organism_group_id );
			SqlParameter i_raw_address = new SqlParameter( "@i_raw_address", SqlDbType.VarChar, 32, "raw_address" );
			i_raw_address.Value = RawAddress;
			Insert.Parameters.Add( i_raw_address );
			SqlParameter i_notes = new SqlParameter( "@i_notes", SqlDbType.Text, 255, "notes" );
			i_notes.Value = GeneNotes;
			Insert.Parameters.Add( i_notes );
			SqlParameter i_relative_address = new SqlParameter( "@i_relative_address", SqlDbType.Decimal, 100, "relative_address" );
			i_relative_address.Value = RelativeAddress;
			Insert.Parameters.Add( i_relative_address );
			__GeneRow.ADOCommands["insert"] = Insert;

			// (mfs)
			// add the SELECT command
			SqlCommand Select = new SqlCommand( "SELECT * FROM " + __TableName + " WHERE id = @s_id;" );
			SqlParameter s_id = new SqlParameter( "@s_id", SqlDbType.UniqueIdentifier, 32, "id");
			s_id.SourceVersion = DataRowVersion.Original;
			s_id.Value = ID;
			Select.Parameters.Add( s_id );
			__GeneRow.ADOCommands["select"] = Select;

			// (mfs)
			// add the UPDATE command
			SqlCommand Update   = new SqlCommand( "UPDATE " + __TableName + " SET homologue_group_id = @u_group_id, chromosome_id = @u_chromosome_id, cytogenic_address = @u_cytogenic_address, genetic_address = @u_genetic_address, organism_group_id = @u_organism_group_id, notes = @u_notes, relative_address = @u_relative_address, raw_address = @u_raw_address WHERE id = @u_id;" );
			SqlParameter u_group_id = new SqlParameter( "@u_group_id", SqlDbType.UniqueIdentifier, 32, "homologue_group_id" );
			u_group_id.Value = HomologueGroupID;
			Update.Parameters.Add( u_group_id );

			SqlParameter u_chromosome_id = new SqlParameter( "@u_chromosome_id", SqlDbType.UniqueIdentifier, 32, "chromosome_id" );
			u_chromosome_id.Value = ChromosomeID;
			Update.Parameters.Add( u_chromosome_id );
			
			SqlParameter u_cytogenic_address = new SqlParameter( "@u_cytogenic_address", SqlDbType.VarChar, 100, "cytogenic_address" );
			u_cytogenic_address.Value = CytogenicAddress;
			Update.Parameters.Add( u_cytogenic_address );

			SqlParameter u_genetic_address = new SqlParameter( "@u_genetic_address", SqlDbType.BigInt, 32, "genetic_address" );
			u_genetic_address.Value = GeneticAddress;
			Update.Parameters.Add( u_genetic_address );

			SqlParameter u_organism_group_id = new SqlParameter( "@u_organism_group_id", SqlDbType.UniqueIdentifier, 32, "organism_group_id" );
			u_organism_group_id.Value = OrganismGroupID;
			Update.Parameters.Add( u_organism_group_id );
			
			SqlParameter u_notes = new SqlParameter( "@u_notes", SqlDbType.Text, 100, "notes" );
			u_notes.Value = GeneNotes;
			Update.Parameters.Add( u_notes );
			
			SqlParameter u_relative_address = new SqlParameter( "@u_relative_address", SqlDbType.BigInt, 100, "relative_address" );
			u_relative_address.Value = RelativeAddress;
			Update.Parameters.Add( u_relative_address );
			
			SqlParameter u_raw_address = new SqlParameter( "@u_raw_address", SqlDbType.VarChar, 100, "raw_address" );
			u_raw_address.Value = RawAddress;
			Update.Parameters.Add( u_raw_address );

			SqlParameter u_id   = new SqlParameter( "@u_id", SqlDbType.UniqueIdentifier, 32, "id");
			u_id.SourceVersion = DataRowVersion.Original;
			u_id.Value = ID;
			Update.Parameters.Add( u_id );

			__GeneRow.ADOCommands["update"] = Update;
			
			// (mfs)
			// add the DELETE command
			SqlCommand Delete = new SqlCommand ( "DELETE FROM " + __TableName + " WHERE id = @d_id;" );
			SqlParameter d_id = new SqlParameter( "@d_id", SqlDbType.UniqueIdentifier, 32, "id");
			d_id.SourceVersion = DataRowVersion.Original;
			d_id.Value = ID;
			Delete.Parameters.Add( d_id );

			__GeneRow.ADOCommands["delete"] = Delete;

		}
		#endregion
		#endregion


		#region Static Methods
		/// <summary>
		/// Return all genes from the system.
		/// </summary>
		/// <returns>
		/// Array of SoapGene objects ready to be sent via SOAP.
		/// </returns>
        
		public static ServerGene[] AllGenes ( )
		{
			SqlCommand command = new SqlCommand(@"
				SELECT g.*
				FROM " + __TableName + @" g
				INNER JOIN molecular_entities me ON g.[id] = me.[id]
				ORDER BY [name];" );
			
			DataSet[] ds = new DataSet[0];
			DBWrapper.LoadMultiple( out ds, ref command );

			ArrayList results = new ArrayList();
			foreach ( DataSet d in ds )
			{
				results.Add( new ServerGene( new DBRow( d ) ) );
			}

			return ( ServerGene[] ) results.ToArray( typeof( ServerGene ) );
		}

        /// <summary>
        /// Return all genes in an organism.
        /// </summary>
        /// <returns>
        /// Array of ServerGene objects.
        /// </returns>
        public static ServerGene[] GetAllGenesForOrganism(Guid organismGroupId)
        {
            SqlCommand command = DBWrapper.BuildCommand(@"
				SELECT g.*
				FROM " + __TableName + @" g
				INNER JOIN molecular_entities me ON g.[id] = me.[id]
                WHERE g.organism_group_id = @orgId;",
          "@orgId", SqlDbType.UniqueIdentifier, organismGroupId);

            DataSet[] ds = new DataSet[0];
            DBWrapper.LoadMultiple(out ds, ref command);

            ArrayList results = new ArrayList();
            foreach (DataSet d in ds)
            {
                results.Add(new ServerGene(new DBRow(d)));
            }

            return (ServerGene[])results.ToArray(typeof(ServerGene));
        }

		/// <summary>
		/// Returns all genes who's name contains the given substring
		/// </summary>
		/// <param name="substring"></param>
		/// <param name="searchMethod"></param>
		/// <returns></returns>
		public static ServerGene[] FindGenes(string substring, SearchMethod searchMethod)
		{
			if ( searchMethod == SearchMethod.Contains || searchMethod == SearchMethod.EndsWith ) substring = "%" + substring;
			if ( searchMethod == SearchMethod.Contains || searchMethod == SearchMethod.StartsWith ) substring += "%";

			SqlCommand command = DBWrapper.BuildCommand(
				@"SELECT g.*
					FROM " + __TableName + @" g
					INNER JOIN molecular_entities me ON g.id = me.id
					WHERE me.name " + ( searchMethod != SearchMethod.ExactMatch ? "LIKE" : "=" ) + @" @substring
					ORDER BY me.[name];",
				"@substring", SqlDbType.VarChar, substring );
			
			DataSet[] ds = new DataSet[0];
			DBWrapper.LoadMultiple( out ds, ref command );

			ArrayList results = new ArrayList();
			foreach ( DataSet d in ds )
			{
				results.Add( new ServerGene( new DBRow( d ) ) );
			}

			return ( ServerGene[] ) results.ToArray( typeof( ServerGene ) );
		}

        /// <summary>
        /// Returns all genes who's name contains the given substring in a specific organism
        /// </summary>
        /// <param name="substring"></param>
        /// <param name="searchMethod"></param>
        /// <returns></returns>
        public static ServerGene[] FindGenes(string substring, SearchMethod searchMethod, Guid orgId)
        {
            if (searchMethod == SearchMethod.Contains || searchMethod == SearchMethod.EndsWith) substring = "%" + substring;
            if (searchMethod == SearchMethod.Contains || searchMethod == SearchMethod.StartsWith) substring += "%";

            SqlCommand command = DBWrapper.BuildCommand(
                @"SELECT g.*
					FROM " + __TableName + @" g
					INNER JOIN molecular_entities me ON g.id = me.id
					WHERE me.name " + (searchMethod != SearchMethod.ExactMatch ? "LIKE" : "=") + @" @substring
                    AND organism_group_id = @orgId
					ORDER BY me.[name];",
                "@substring", SqlDbType.VarChar, substring,
                "@orgId", SqlDbType.UniqueIdentifier, orgId);

            DataSet[] ds = new DataSet[0];
            DBWrapper.LoadMultiple(out ds, ref command);

            ArrayList results = new ArrayList();
            foreach (DataSet d in ds)
            {
                results.Add(new ServerGene(new DBRow(d)));
            }

            return (ServerGene[])results.ToArray(typeof(ServerGene));
        }

		/// <summary>
		/// Return a gene with given ID.
		/// </summary>
		/// <param name="id">
		/// The Guid of the desired gene.
		/// </param>
		/// <returns>
		/// SoapGene object ready to be sent via SOAP.
		/// </returns>
		public new static ServerGene Load ( Guid id )
		{
			return new ServerGene( LoadRow ( id ) );
		}

		/// <summary>
		/// Given a row from the base class, calls LoadRow on the base class id
		/// </summary>
		/// <param name="molecularEntityRow"></param>
		/// <returns></returns>
        public static ServerGene LoadFromBaseRow ( DBRow molecularEntityRow )
        {
            return new ServerGene(LoadRow(molecularEntityRow.GetGuid("id")), molecularEntityRow);
        }

		/// <summary>
		/// Return the row for an object with a given ID.
		/// </summary>
		/// <param name="id"></param>
		/// <returns></returns>
		protected new static DBRow LoadRow ( Guid id )
		{
			SqlCommand command = new SqlCommand( "SELECT * FROM " + __TableName + " WHERE id = @id;" );
			SqlParameter ident = new SqlParameter( "@id", SqlDbType.UniqueIdentifier );
			ident.SourceVersion = DataRowVersion.Original;
			ident.Value = id;
			command.Parameters.Add( ident );

			DataSet ds = new DataSet();
			DBWrapper.LoadSingle( out ds, ref command );

			return new DBRow( ds );
		}
        /// <summary>
        /// Return the number of pathway-related genes in the database
        /// </summary>
        /// <returns></returns>
        public static int GetNumOfPathwayGenes()
        {
            string query = @"SELECT count(DISTINCT ge.gene_id)
                                 FROM pathways pw, pathway_processes pp, catalyzes c, gene_encodings ge
                                 WHERE pw.id = pp.pathway_id
                                 AND pp.process_id = c.process_id
                                 AND c.gene_product_id = ge.gene_product_id";

            return int.Parse(DBWrapper.Instance.ExecuteScalar(query).ToString());
        }

        /// <summary>
        /// Return the total number of genes in the database
        /// </summary>
        /// <returns></returns>
        public static int GetNumOfGenes()
        {
            string query = @"SELECT count(id)
                                 FROM genes";
                                 
            return int.Parse(DBWrapper.Instance.ExecuteScalar(query).ToString());
        }

        /// <summary>
        /// Return the total number of genes for an organism
        /// </summary>
        /// <returns></returns>
        public static int GetNumOfGenes(string orgId)
        {
            string query = @"SELECT count(id) FROM genes WHERE organism_group_id = '" + orgId + "'";

            return int.Parse(DBWrapper.Instance.ExecuteScalar(query).ToString());
        }

		
		#region Encodes Relation
		/// <summary>
		/// Add a gene encoding relationship
		/// </summary>
		/// <param name="gene_id"></param>
		/// <param name="gene_product_id"></param>
		public static void AddGeneEncoding ( Guid gene_id, Guid gene_product_id )
		{
			//(bse)
			// check if the process already belongs to the pathway
			//
			if ( !GeneEncodingExists(gene_id, gene_product_id ) )
			{
				DBWrapper db = DBWrapper.Instance;
				db.ExecuteNonQuery(
					"INSERT INTO gene_encodings (gene_id, gene_product_id) VALUES (@gene_id, @gene_product_id);",
					"@gene_id", SqlDbType.UniqueIdentifier, gene_id,
					"@gene_product_id", SqlDbType.UniqueIdentifier, gene_product_id);
			}
			else 
			{
				//do nothing, the process is already part of the pathway
			}
		}

		/// <summary>
		/// Check if a gene encoding relationship already exists
		/// </summary>
		/// <param name="gene_id"></param>
		/// <param name="gene_product_id"></param>
		public static bool GeneEncodingExists ( Guid gene_id, Guid gene_product_id )
		{
			SqlCommand command = DBWrapper.BuildCommand(
				"SELECT * FROM gene_encodings WHERE gene_id = @gene_id AND gene_product_id = @gene_product_id;",
				"@gene_id", SqlDbType.UniqueIdentifier, gene_id,
				"@gene_product_id", SqlDbType.UniqueIdentifier, gene_product_id);

			DataSet[] ds;
			if (DBWrapper.LoadMultiple(out ds, ref command) < 1)
				return false;
			return true;
		}

		/// <summary>
		/// Remove gene encoding relationship
		/// </summary>
		/// <param name="gene_id"></param>
		/// <param name="gene_product_id"></param>
		public static void RemoveGeneEncoding ( Guid gene_id, Guid gene_product_id )
		{
			if (DBWrapper.Instance.ExecuteNonQuery(				
				"DELETE FROM gene_encodings WHERE gene_id = @gene_id AND gene_product_id = @gene_product_id;",
				"@gene_id", SqlDbType.UniqueIdentifier, gene_id,
				"@gene_product_id", SqlDbType.UniqueIdentifier, gene_product_id) < 1)
			{
				throw new DataModelException("RemoveGeneEncoding failed: geneId={0}, geneProductId={1}!", gene_id, gene_product_id);
			}
		}

		/// <summary>
		/// Returns all pathways that involve processes related to gene products ( only through 
		///  the gene_products_and_processes table ) that are encoded by the given gene.
		/// </summary>
		/// <param name="geneId"></param>
		/// <returns></returns>
		public static ServerPathway[] GetAllPathwaysForGene ( Guid geneId )
		{
			SqlCommand command = DBWrapper.BuildCommand( 
                @"SELECT p.* 
                    FROM pathways p 
                    WHERE p.id IN ( SELECT pp.pathway_id 
                                    FROM pathway_processes pp INNER JOIN catalyzes gpp ON pp.process_id = gpp.process_id 
                                    WHERE gpp.gene_product_id IN ( 	SELECT ge.gene_product_id 
                                                                    FROM gene_encodings ge 
                                                                    WHERE ge.gene_id = @gene_id ) );",
				"@gene_id", SqlDbType.UniqueIdentifier, geneId );
			
			ArrayList results = new ArrayList();
			DataSet[] ds;
			if (DBWrapper.LoadMultiple(out ds, ref command) > 0)
			{
				foreach(DataSet d in ds)
				{
					results.Add(new ServerPathway( new DBRow( d ) ) );
				}
			}
			return (ServerPathway[])results.ToArray(typeof(ServerPathway));
		}


		/// <summary>
		/// Getting the organism or group for this gene
		/// </summary>
		/// <param name="geneId"></param>
		/// <returns></returns>
		public static ServerOrganism GetOrganismForGene ( Guid geneId )
		{
			SqlCommand command = DBWrapper.BuildCommand( 
				@"SELECT o.*
					FROM organisms o, genes g
					WHERE g.organism_group_id = o.[id]
					AND g.[id] = @geneId;",
				"@geneId", SqlDbType.UniqueIdentifier, geneId );

			return ServerOrganism.LoadSingle(command);
		}


		#endregion

		#endregion

	} // End class

} // End namespace


#region Change Log
//----------------------------- END OF SOURCE ----------------------------

/*------------------------------- Change Log -----------------------------
	$Id: ServerGene.cs,v 1.1 2008/05/16 21:15:53 mustafa Exp $
	$Log: ServerGene.cs,v $
	Revision 1.1  2008/05/16 21:15:53  mustafa
	*** empty log message ***
	
	Revision 1.5  2007/05/11 17:02:44  ali
	*** empty log message ***
	
	Revision 1.4  2007/05/11 08:28:48  ali
	Fixed the issues related to significant pathways query for a given set of genes.
	
	Revision 1.3  2007/05/04 12:13:06  ali
	A built-in query for finding pathways that are significantly enriched with a given set of genes is added.
	
	Hypergeometric Distribution was not implemented correctly, now it should work fine.
	
	A generic QuickSort function is added.
	
	Revision 1.2  2006/11/26 21:49:25  ali
	*** empty log message ***
	
	Revision 1.1  2006/07/31 19:37:43  greg
	Ported from VS7 to VS8.  The system should compile, but there are definitely issues with the site that are still at large.
	
	Revision 1.39  2006/06/15 02:45:27  gokhan
	*** empty log message ***
	
	Revision 1.38  2006/06/05 22:40:08  brandon
	Made DisplayGeneDetail functional.  added function to ServerGene to get all homologues.
	Fixed a bug in ServerGeneProduct.GetAllOrganisms() so it now returns distinct organisms (there were duplicates before)
	
	Revision 1.37  2006/05/23 18:29:32  greg
	Many old SQL queries were updated/optimized, and a bug that causes the system to crash when trying to navigate after viewing the details of an object through the Java applet is also fixed.  This required some semi-substantial modifications to LinkHelper.cs and SearchPagination.ascx.cs to allow for a slightly different method of dealing with query parameters.
	
	Revision 1.36  2006/05/18 19:01:47  greg
	 - Pathway menu expansion
	When going through the pathways menu in the control bar, the menu that should be open isn't.  Now it is.
	
	 - SQL injection stuff
	More queries were rewritten to prevent SQL injection, and some were also rewritten to be a little more aesthetically pleasing.
	
	 - Finding SQL bugs
	SQL bugs that have arisen as a result of schema changes are still being checked for.  Any that I find are being sent to Ali for rewriting and reintegration.
	
	Revision 1.35  2006/05/18 05:33:30  gokhan
	*** empty log message ***
	
	Revision 1.34  2006/05/16 19:47:27  gokhan
	*** empty log message ***
	
	Revision 1.33  2006/05/11 21:18:33  brendan
	Fixed numerous bugs, basic browsing starting to work again
	
	Revision 1.32  2006/05/11 15:47:20  brendan
	Removed remaining SearchMethod magic strings; refactored OrgMeta back into ServerOrganismGroup, fixed many PathwaysLib warnings.
	
	Revision 1.31  2006/05/10 02:40:17  ali
	Server Objects have been modified to make them compliant with the recent schema changes concerning the addition of several entity_type tables into the database.
	
	Revision 1.30  2006/04/21 17:37:29  michael
	*** empty log message ***
	
	Revision 1.29  2006/04/12 20:21:38  brian
	*** empty log message ***
	
	Revision 1.28.8.1  2006/03/22 19:48:06  brian
	*** empty log message ***
	
	Revision 1.28  2005/11/07 17:28:26  brendan
	New generic graph building code, exposed via a new web service call.
	
	Revision 1.27  2005/11/02 20:35:16  fatih
	Test functions are working for pathwayslib objects
	
	Revision 1.26  2005/10/31 06:10:17  fatih
	*** empty log message ***
	
	Revision 1.25  2005/08/24 22:27:52  michael
	Fixing SQL Connection Overflow bug
	
	Revision 1.24  2005/08/01 16:32:31  brandon
	added "ORDER BY name" clause to the All... and Find... functions in the server objects
	
	Revision 1.23  2005/07/27 22:16:25  brandon
	Added find (search by substring) functions in ServerPathway and ServerProcess.  Fixed the find function in the others ( the 'Ends with' query was wrong )
	
	Revision 1.22  2005/07/21 19:59:13  brandon
	add function to ServerGene.cs to get the organism or organism group for a gene
	
	Revision 1.21  2005/07/21 18:45:50  brandon
	can get Pathways, roles, and processes for Gene products now
	
	Revision 1.20  2005/07/20 22:55:56  brandon
	I think I fixed the GetChromosome problem in ServerGene.cs, but maybe not
	
	Revision 1.19  2005/07/20 18:02:19  brandon
	added function to ServerPathway: GetConnectedPathways ( ), which returns an array of ConnectedPathwayAndCommonProcesses objects.  This new object has three properties:
	ServerPathway ConnectedPathway- (to be listed as a connected pathway)
	ServerProcess[] SharedProcesses - (shared by two pathways)
	ServerMolecularEntity[] SharedExclusiveMolecules - (molecules shared
	by two pathways but are not included in any process in SharedProcesses)
	
	Revision 1.18  2005/07/19 18:15:36  brandon
	Added a bunch of XML comments, also changed get all processes for pathway function to remove duplicates
	
	Revision 1.17  2005/07/18 20:31:13  brandon
	changed GetAllPathways in ServerMolecularEntity.cs to work for all types of molecular entity.  Added a static method to ServerGene to get all pathways for gene products that the gene encodes
	
	Revision 1.16  2005/07/15 21:02:00  brandon
	added more queries
	
	Revision 1.15  2005/07/13 22:14:12  brandon
	bug fixes, updated ServerBasicMolecule for inheritance, but it's not finished so don't use it yet.
	
	Revision 1.14  2005/07/13 16:41:45  brandon
	Added a bunch of XML comments where they were missing.
	Changed ServerCatalyze so that it loads a single object from a given ec number instead of an array.
	
	Revision 1.13  2005/07/11 22:28:57  brendan
	Added inheritance support for GeneProduct and Protein, but they are not fully tested yet.
	
	Revision 1.12  2005/07/11 21:01:52  brendan
	Inheritance now working for Gene/MolecularEntity and the ServerObjectInheritance tests completes successfully.
	
	Revision 1.11  2005/07/08 20:36:39  brandon
	changed LoadDataSet to LoadRow in all the Server objects
	
	Revision 1.10  2005/07/08 19:32:05  brandon
	fixed ServerCatalyze, sort of,  and uh, this project builds now
	
	Revision 1.9  2005/07/01 20:47:39  brendan
	Work on inheritance & the object wrapper.
	
	Revision 1.8  2005/06/29 22:06:10  brendan
	Working on adding support for inheritance between MolecularEntity and Gene.
	
	Revision 1.7  2005/06/29 16:50:20  brandon
	Fixed a couple of syntax errors
	
	Revision 1.6  2005/06/29 16:44:53  brandon
	Added Insert, Update, and Delete support to these files if they didn't already have it
	
	Revision 1.5  2005/06/28 23:20:25  brendan
	Fixed Gene, MolecularEntity, Organism, and Process to reflect recent wrapper object design changes.
	
	Revision 1.4  2005/06/27 15:44:22  brandon
	revised ServerOrganism.cs to the new format, not sure when to use 'organism_notes' vs. 'notes'
	
	Revision 1.3  2005/06/24 21:57:32  brendan
	Checkin of work on database object design.
	
	Revision 1.2  2005/06/24 20:57:34  brandon
	added LoadDecimal, LoadLong, SetDecimal, and SetLong to DBRow.cs
	
	Revision 1.1  2005/06/23 21:54:42  brandon
	two new files, see if inheritance works

------------------------------------------------------------------------*/
#endregion